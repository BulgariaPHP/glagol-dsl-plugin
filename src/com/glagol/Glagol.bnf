{
  parserClass="com.glagol.parser.GlagolParser"
  parserUtilClass="com.glagol.parser.GlagolParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Glagol"
  psiImplClassSuffix="Impl"
  psiPackage="com.glagol.psi"
  psiImplPackage="com.glagol.psi.impl"

  elementTypeHolderClass="com.glagol.psi.GlagolTypes"
  elementTypePrefix="G_"
  elementTypeClass="com.glagol.psi.GlagolElementType"
  tokenTypeClass="com.glagol.psi.GlagolTokenType"

  extends(".*type")=type

  tokens = [
    OP_EQ="="
    SEMICOLON=";"
    COLON=":"
    DOUBLE_COLON="::"
    COMMA=","
    LEFT_BRACE="{"
    RIGHT_BRACE="}"
    LEFT_BRACKET="["
    RIGHT_BRACKET="]"
    LEFT_PAREN="("
    RIGHT_PAREN=")"
    AT="@"
    TYPED_LIST="[]"

    LT="<"
    GT=">"

    KW_NS="namespace"
    KW_ENTITY="entity"
    KW_VALUE="value"
    KW_REPOSITORY="repository"
    KW_IMPORT="import"
    KW_ALIAS="as"
    KW_REL="relation"
    KW_GET="get"
    KW_SELFIE="selfie"
    KW_NEW="new"
    KW_PRIMARY="primary"

    TYPE_STRING="string"
    TYPE_INT="int"
    TYPE_BOOL="regexp:bool|boolean"
    TYPE_FLOAT="float"
    TYPE_VOID="void"

    int="regexp:\d+"
    decimal="regexp:\d+\.\d+"
    symbol_name="regexp:[A-Z]\w*"
    boolean="regexp:true|false"
    rel_dir="regexp:one|many"
    id="regexp:[a-z][a-zA-Z]*"
    string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\\"|\\\'|\\)*\")"
    line_comment="regexp://.*"
    block_comment="regexp:/\*([^])*\*/"
  ]
}

root ::= !<<eof>> annotation* 'namespace' qualified_name import_artifact* declaration?

qualified_name ::= symbol_name ('::' symbol_name)*

import_artifact ::= 'import' qualified_name ('as' symbol_name)? ';'

declaration ::= annotation* (decl_entity | decl_value)

decl_entity ::= 'entity' symbol_name '{' member* '}'
decl_value ::= 'value' symbol_name '{' member* '}'

annotation ::= '@' id '=' annotation_arg | '@' id '(' annotation_arg_sequence ')'| '@' id
private annotation_arg ::= literal | annotation_arg_list | annotation_arg_map
private annotation_arg_list ::= '[' annotation_arg_sequence? ']'
private annotation_arg_sequence ::= (annotation_arg ',')* annotation_arg
private annotation_arg_map ::= '[' ((annotation_arg_pair ',')* annotation_arg_pair)? ']'
private annotation_arg_pair ::= annotation_arg ':' annotation_arg

member ::= annotation* (property | constructor)

property ::= type id ('=' property_default_value)? ';'
property_default_value ::= default_value

constructor ::= symbol_name '(' abstract_parameters? ')' '{' '}'

private abstract_parameters ::= (abstract_parameter ',')* abstract_parameter
private abstract_parameter ::= annotation* parameter
private parameter ::= type id ('=' default_value)?

default_value ::= literal | dv_list | get | new

dv_list ::= '[' dv_sequence? ']'
dv_sequence ::= (default_value ',')* default_value

literal ::= string | int | decimal | boolean

get ::= 'get' type
new ::= 'new' artifact_type '(' dv_sequence? ')'

type ::= scalar_type
       | list_type
       | map_type
       | repository_type
       | artifact_type
       | selfie_type

selfie_type ::= 'selfie'
scalar_type ::= TYPE_BOOL | TYPE_FLOAT | TYPE_INT | TYPE_STRING | TYPE_VOID
list_type ::= type '[]'
map_type ::= '{' type ',' type '}'
repository_type ::= 'repository' '<' symbol_name '>'
artifact_type ::= symbol_name
