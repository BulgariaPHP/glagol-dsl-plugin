{
  parserClass="com.glagol.parser.GlagolParser"
  parserUtilClass="com.glagol.parser.GlagolParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Glagol"
  psiImplClassSuffix="Impl"
  psiPackage="com.glagol.psi"
  psiImplPackage="com.glagol.psi.impl"

  elementTypeHolderClass="com.glagol.psi.GlagolTypes"
  elementTypePrefix="G_"
  elementTypeClass="com.glagol.psi.GlagolElementType"
  tokenTypeClass="com.glagol.psi.GlagolTokenType"

  extends(".*type")=type
  extends(".*expr")=expr

  consumeTokenMethod(".*_expr|expr")="consumeTokenFast"

  tokens = [
    OP_EQ="="
    SEMICOLON=";"
    COLON=":"
    DOUBLE_COLON="::"
    COMMA=","
    LEFT_BRACE="{"
    RIGHT_BRACE="}"
    LEFT_BRACKET="["
    RIGHT_BRACKET="]"
    LEFT_PAREN="("
    RIGHT_PAREN=")"
    AT="@"
    TYPED_LIST="[]"
    MINUS="-"
    PLUS="+"
    DOT="."
    ASTERIX="*"
    PERCENT="%"
    SLASH="/"
    LT="<"
    GT=">"
    LTE="<="
    GTE=">="
    EQ="=="
    NON_EQ="!="
    AND="&&"
    OR="||"
    QUESTION_MARK="?"

    KW_NS="namespace"
    KW_ENTITY="entity"
    KW_VALUE="value"
    KW_REPOSITORY="repository"
    KW_IMPORT="import"
    KW_ALIAS="as"
    KW_REL="relation"
    KW_GET="get"
    KW_SELFIE="selfie"
    KW_NEW="new"
    KW_PRIMARY="primary"
    KW_WHEN="when"
    KW_THIS="this"

    TYPE_STRING="string"
    TYPE_INT="int"
    TYPE_BOOL="regexp:bool|boolean"
    TYPE_FLOAT="float"
    TYPE_VOID="void"

    int="regexp:\d+"
    decimal="regexp:\d+\.\d+"
    symbol_name="regexp:[A-Z]\w*"
    boolean="regexp:true|false"
    rel_dir="regexp:one|many"
    id="regexp:[a-z][a-zA-Z]*"
    string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\\"|\\\'|\\)*\")"
    line_comment="regexp://.*"
    block_comment="regexp:/\*([^])*\*/"
  ]
}

root ::= !<<eof>> annotation* 'namespace' qualified_name import_artifact* declaration?

qualified_name ::= symbol_name ('::' symbol_name)*

import_artifact ::= 'import' qualified_name ('as' symbol_name)? ';'

declaration ::= annotation* (decl_entity | decl_value)

decl_entity ::= 'entity' symbol_name '{' member* '}'
decl_value ::= 'value' symbol_name '{' member* '}'

annotation ::= '@' id '=' annotation_arg | '@' id '(' annotation_arg_sequence ')'| '@' id
private annotation_arg ::= literal | annotation_arg_list | annotation_arg_map
private annotation_arg_list ::= '[' annotation_arg_sequence? ']'
private annotation_arg_sequence ::= (annotation_arg ',')* annotation_arg
private annotation_arg_map ::= '[' ((annotation_arg_pair ',')* annotation_arg_pair)? ']'
private annotation_arg_pair ::= annotation_arg ':' annotation_arg

member ::= annotation* (property | constructor)

property ::= type id ('=' property_default_value)? ';'
property_default_value ::= default_value

constructor ::= symbol_name '(' abstract_parameters? ')' '{' '}' guard?

private guard ::= 'when' expr ';'

private abstract_parameters ::= (abstract_parameter ',')* abstract_parameter
private abstract_parameter ::= annotation* parameter
private parameter ::= type id ('=' default_value)?

default_value ::= literal | dv_list | get | new

dv_list ::= '[' dv_sequence? ']'
dv_sequence ::= ((default_value ',')* default_value) | (default_value ',')+

literal ::= string | int | decimal | boolean

get ::= 'get' type
new ::= 'new' artifact_type '(' dv_sequence? ')'

type ::= scalar_type
       | list_type
       | map_type
       | repository_type
       | artifact_type
       | selfie_type

selfie_type ::= 'selfie'
scalar_type ::= TYPE_BOOL | TYPE_FLOAT | TYPE_INT | TYPE_STRING | TYPE_VOID
list_type ::= type '[]'
map_type ::= '{' type ',' type '}'
repository_type ::= 'repository' '<' symbol_name '>'
artifact_type ::= symbol_name

expr ::= literal_expr
       | list_expr
       | map_expr
       | negative_expr
       | positive_expr
       | invoke_group
       | field_expr
       | variable_expr
       | new_expr
       | bracket_expr
       | this_expr
       | mul_group
       | add_group
       | remainder_expr
       | bin_rel_group
       | bin_logic_group
       | ternary_expr


private bin_logic_group ::= and_expr | or_expr
private bin_rel_group ::= lt_expr | lte_expr | gt_expr | gte_expr | eq_expr | non_eq_expr
private add_group ::= plus_expr | minus_expr
private mul_group ::= product_expr | division_expr
private invoke_group ::= invoke_expr | invoke_final_expr

ternary_expr ::= expr '?' expr ':' expr
and_expr ::= expr '&&' expr
or_expr ::= expr '||' expr
lt_expr ::= expr '<' expr
lte_expr ::= expr '<=' expr
gt_expr ::= expr '>' expr
gte_expr ::= expr '>=' expr
eq_expr ::= expr '==' expr
non_eq_expr ::= expr '!=' expr
plus_expr ::= expr '+' expr
minus_expr ::= expr '-' expr
product_expr ::= expr '*' expr
division_expr ::=  expr '/' expr
remainder_expr ::= expr '%' expr
literal_expr ::= literal
list_expr ::= '[' list_seq_expr? ']'
list_seq_expr ::= seq_expr | (expr ',')+
seq_expr ::= (expr ',')* expr
map_expr ::= '{' map_seq_expr? '}'
map_seq_expr ::= ((map_pair_expr ',')* map_pair_expr) | (map_pair_expr ',')+
map_pair_expr ::= expr ':' expr
negative_expr ::= '-' expr
positive_expr ::= '+'
invoke_expr ::= expr '.' invoke_final_expr
invoke_final_expr ::= id '(' seq_expr? ')'
field_expr ::= expr '.' id
variable_expr ::= id
new_expr ::= 'new' symbol_name '(' seq_expr? ')'
bracket_expr ::= '(' expr ')'
this_expr ::= 'this'
